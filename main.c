/*
 * @file main.c
 * @brief Main file for DragonflySynthSW project.
 *
 * This software implements functionality for the Dragonfly Synthesizer Module.
 * It is an event-driven architecture. The software interacts with the
 * following peripherals:
 *	- LEDs (Writes to digital pins)
 *	- Push buttons (Reads and debounces digital pins)
 *	- Potentiometers (Reads and interprets ADCs)
 *	- DAC (Sets output voltage via SPI Communication Protocol)
 *  - USB (Reads key presses via UART Communication Protocol)
 *
 * The audio waveform generated by this module is output from the DAC. The
 * peripherals allow to user to modify settings corresponding to the waveform.
 * Some features include ADSR envelope control, custom waveform shapes, and
 * other audio effects. The USB device connected receives key presses to
 * generate notes from a keyboard emulator.
 *
 * The input peripherals are read and update waveform settings every 1ms. The
 * DAC is written to every 25us yielding a 40 kHz sampling rate.
 *
 * @author Garrett Knuf
 */ 

#define F_CPU 16000000UL

#include <avr/io.h>
#include <avr/interrupt.h>
#include <stdbool.h>
#include <util/delay.h>

#include "adsr_controllers.h"
#include "button.h"
#include "dac_util.h"
#include "leds.h"
#include "notes.h"
#include "timers.h"

static uint8_t adsr_level;

int main(void)
{
	// Setup hardware and software interfaces
	adsr_controllers_init();
	button_init();
    dac_init();
	leds_init();
	notes_init();
	
	const Waveshape init_shape = kWaveshapeSquare;
	notes_set_freq(250);
	notes_set_waveshape(init_shape);
	leds_off(kWaveshapeSquare);
	
	adsr_controllers_set_attack(300);
	adsr_controllers_set_decay(50);
	adsr_controllers_set_sustain(50);
	adsr_controllers_set_release(500);
	
	// Start timers and enable global interrupts
	timers_1ms_init();
	timers_25us_init();
	sei();
	
    while (1) 
    {
		// Event-driven architecture. Main loop is empty.
    }
}

int count = 0;
// Event handler for 1ms timer compare match interrupts
ISR(TIMER0_COMPA_vect) {
	button_debounce();
	bool button_pressed = button_get_status();
	
	if (button_pressed) {
		// Switch to next waveshape
		Waveshape current_shape = notes_get_waveshape();
		Waveshape next_shape = (current_shape + 1) % kWaveshapeCount;
		
		leds_off(current_shape);
		leds_on(next_shape);
		notes_set_waveshape(next_shape);
	}
	
	adsr_controllers_update();
	adsr_level = adsr_controllers_get_level();
	
	count++;
	if (count == 1000) {
		adsr_controllers_reset();
		notes_set_freq(440);
	} else if (count == 2000) {
		adsr_controllers_reset();
		notes_set_freq(392);
	} else if (count == 3000){
		adsr_controllers_reset();
		notes_set_freq(349);
		count = 0;
	}
	
}

// Event handler for 25us timer compare match interrupts
ISR(TIMER2_COMPA_vect) {
	notes_update();
	uint8_t output = notes_get_output();
	
	switch (adsr_level) {
		case 0:
			// volume off
			output = 0;
			break;
		case 1:
			// 1/8 volume
			output >>= 3;
			break;
		case 2:
			// 1/4 volume
			output >>= 2;
			break;
		case 3:
			// 3/8 volume
			output >>= 2;
			output += output >> 1;
			break;
		case 4:
			// 1/2 volume
			output >>= 1;
			break;
		case 5:
			// 5/8 volume
			output >>= 1;
			output += output >> 2;
			break;
		case 6:
			// 3/4 volume
			output >>= 1;
			output += output >> 1;
			break;
		case 7:
			// 7/8 volume
			output >>= 1;
			output += (output >> 1) + (output >> 2);
			break;
		default:
			// full volume
			break;		
	}
	
	dac_set_output(output);
}


